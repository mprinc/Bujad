;activities methods

to-report activitiesForFriendship [actorMaster actorSlave] 
  let factivities []
  let activitiesNum 0
  ask actorMaster[    
    let activityLinksOut sort my-out-activity-actors with [happened = true]
    foreach activityLinksOut[
      let activityOut [end1] of ?
      if(activityOut = actorMaster)[set activityOut [end2] of ?]
      ask activityOut[
        ; in-link-from
        let activityLinkOut out-activity-actor-to actorSlave
        if((activityLinkOut != nobody) and ([happened] of activityLinkOut) = true) [
          set factivities lput activityLinkOut factivities
          set activitiesNum activitiesNum + 1
        ]
      ]
    ]
    
    let activityLinksIn sort my-in-activity-actors with [happened = true]
    foreach activityLinksIn[
      let activityIn [end1] of ?
      if(activityIn = actorMaster)[set activityIn [end2] of ?]
      ask activityIn[
        ; in-link-from
        let activityLinkIn in-activity-actor-from actorSlave
        if((activityLinkIn != nobody) and ([happened] of activityLinkIn) = true) [
          set factivities lput activityLinkIn factivities
          set activitiesNum activitiesNum + 1  
        ]
      ]
    ]
  ]
  print word "activitiesNum:" activitiesNum
  foreach(sort activities)[
      print word "activity:" ?
  ]

  report activities  
end

to-report price_last_activities [actorMaster actorSlave period]
  ; IMPORTANT: for now, we count price of all activities to be = 1
  let price 0
  let factivities activitiesForFriendship actorMaster actorSlave
  ;print word "factivities:" count factivities
  let min_tick ticks - period
  ;set price count filter [ ([time] of ?) > tick ] factivities
  ;set price count (factivities with [ time > tick ])
  foreach(sort factivities)[
    if(([time] of ?) > min_tick)[
      set price price + 1
    ]
  ]  
  report price
end