; In order to rise error (to make it possible for this file to be loaded inside of NetLogo environment) just keep this line uncommented. There are too many error to NetLogo not notice them ;) :x. Comment it while you are running code. You need it only on loading model in NetLogo

globals[
    activities-num-emitted   ; total number of activities emitted in the system from all actors cumullatively
]

; we iterate through activities and remove obsolated ones together with their links
to remove-obsolated-activities
  let activitySelected first activities-list
  let lastValidTime ticks - Activity-forgetting-time

  while [[time] of activitySelected < lastValidTime][
    set activities-list but-first activities-list
    ask activitySelected[
      ; kill all links
      
      ; equivalent to command my-out-<breeds>
      ask my-out-activity-actors [die]
      ; equivalent to command my-in-<breeds>
      ask my-in-activity-actors [die]
      ask my-iamwhat-activities [die]
      ask my-activity-type-activities [die] 
    ]
    ask activitySelected[die]
    set activitySelected first activities-list
  ]
end

to-report diffuse-activity
  let activity-current nobody
  let actor-difuser nobody

  ;; create activity breed that will represent the activity that just happened
  create-activities 1
  [
    if(Last-activity-links and length activities-list > 1)[
      let activityLast item (length activities-list - 2) activities-list  
      ask activityLast[
        ; equivalent to command my-out-<breeds>
        ask my-out-activity-actors [
          if(Links-show-extra = false)[set hidden? true]
        ]
        ; equivalent to command my-in-<breeds>
        ask my-in-activity-actors [
        if(Links-show-extra = false)[set hidden? true]
        ]
      ]
    ]
      
    set activities-list lput self activities-list
    set activity-current self
    
    setxy (max-pxcor - 5) 0 ; we need to update it AFTER we se if activity DID happen in the ind
    set size 5
    ;set hidden? true
    set shape "flower"
    set time ticks
  ]
  
  ; ask actor (actor-difuser) that is not in emittion saturation to emit an activity
  ; it will decide if it will emit it in according to emission probability
  let actor-difuser-potential one-of actors with [price-emitted < price-emission-limit]

  if(actor-difuser-potential != nobody)[
    ask actor-difuser-potential [
      ifelse (random-float 1 <= Activity-emission-probability)[
        set actor-difuser self
        actor-diffuse-activity-from activity-current
      ][
      ; type "actor : " type self type "rejected to diffuse activity\n"
      ]
    ]
  ]
  
  ; if actor 'refused' to difuse activity we have to revoke activity
  ifelse (actor-difuser = nobody)[
    ask activity-current [die]
    set activities-list but-last activities-list
  ][
    ; we add 1 since we will put overflowed activities on the first position
    let activity-y (max-pycor - 15 * (1 + length activities-list))
  
    ; type "activity-y = " type activity-y type ", min-pycor = " type min-pycor type "\n"
    if(activity-y < min-pycor + 15)[
      ask activities with [ycor < (max-pycor - 8)][
        set ycor ycor + 8;
      ]
      set activity-y min-pycor + 15
    ]

    ; all overflowed activites should be hidden together with their activity-actors links
    ask activities with [ycor >= (max-pycor - 5)][
      set hidden? true;

      ; equivalent to command my-out-<breeds>
      ask my-out-activity-actors [
        set hidden? true;
      ]
      ; equivalent to command my-in-<breeds>
      ask my-in-activity-actors [
        set hidden? true;
      ]
    ]

    ask activity-current[
      set ycor activity-y
    ]
  ]
  report activity-current
end

; the chosen actor-difuser will send activity activity-current to one (soon more) other actors that didn't reach absorption limit
to actor-diffuse-activity-from [activity-current]
  ; type "actor : " type self type "is diffusing activity\n"

  actor-populate-activity activity-current
  let activity-type-current nobody
  ; no need for one-of (there has to be only one link) except for de-agentseting to breed
  ask activity-current[set activity-type-current one-of activity-type-activity-neighbors]

  ; consider emitting price
  set price-emitted price-emitted + [price-to-diffuse] of activity-type-current

  ; create a link between actor emitter and activity
  create-activity-actor-to activity-current [
    set shape "default"
    set color yellow
    set happened true
    if(not Last-activity-links and Links-show-extra = false)[set hidden? true]
  ]
  
  ; find (if any) actor that emitter is emitting activity toward
  let actor-absorbers actor-sender-choses-receiver-for-emitting-activity activity-current
  if(actor-absorbers != nobody)[

    ; ask absorber if he is willing to absorb
    let actorReceiverAccepted actor-receiver-decides-on-absorption-of-activity self actor-absorbers activity-current

    ; connect activity with absorber
    ask actor-absorbers[
      create-activity-actor-from activity-current [
        set shape "default"
        
        ifelse(actorReceiverAccepted)[
          set color red
          set happened true
        ][
          set color blue
          set happened false
        ]

        if(not Last-activity-links and Links-show-extra = false)[set hidden? true]
      ]
    ]
    
    if(actorReceiverAccepted)[
      ask actor-absorbers [
        ; consider absorbtion price
        set price-absorbed price-absorbed + [price-to-absorb] of activity-type-current
        let friendship-absorber friendship-with myself
        visualization-set-state-friendship friendship-absorber "link:activity:sent"
      ]
      ; affect-relatinships-by-activity activity-current ; DEPRICATED-OLD-MODEL
    ]
  ]
end

; in the context of actor-sender
; it returns the most appropriate actor
to-report actor-sender-choses-receiver-for-emitting-activity [activity-current]
  let actorReceiver nobody
  
  ; check if we are in the Friendship Manage mode and
  ; check if there are some dying friendship
  if(FM?)[
    let minTimeToLostValue 1000000000000000;
    let  minTimeToLostLink no-links;
    let  minTimeToLostActor nobody;
    let timeToLostValue 1000000000000000;

    foreach sort friendship-neighbors[
      ; show word "? (actor): " ?
      let friendshipSelected friendship-with ?
      ; show word "friendshipSelected: " friendshipSelected
      set timeToLostValue actor-get-turtle-link-endpoint-value friendshipSelected "time-to-lost"
      if(timeToLostValue < minTimeToLostValue)[
        set minTimeToLostValue timeToLostValue
        set minTimeToLostLink friendshipSelected
        set minTimeToLostActor ?
      ]
    ]
    ; do not react if the minimum lost time over all nodes is higher than time on what we should triger reaction
    if(minTimeToLostValue <= Friendship-Triger-On-Time)[
      set actorReceiver minTimeToLostActor
    ]
  ]

  if(actorReceiver != nobody and Chooser-whom-to-send = "anyone")[ ; IMPLEMENTED!
    set actorReceiver one-of other actors with [price-absorbed < price-absorption-limit];
  ]
  if(actorReceiver != nobody and Chooser-whom-to-send = "friends")[ ; IMPLEMENTED!
    set actorReceiver one-of friendship-neighbors with [price-absorbed < price-absorption-limit];
  ]
  if(actorReceiver != nobody and Chooser-whom-to-send = "popularity")[
    ;let actorsSorted sort actors
    let actorsSorted sort friendship-neighbors
    let popularitySum 0
    foreach actorsSorted[
      set popularitySum popularitySum + [popularity] of ?
    ]

    let probabilityAdopted random-float popularitySum
    ;show word "popularitySum : " word popularitySum word ", probabilityAdopted = " probabilityAdopted

    set popularitySum 0
    foreach actorsSorted[
      set popularitySum popularitySum + [popularity] of ?
      if(actorReceiver = nobody and popularitySum > probabilityAdopted)[
        set actorReceiver ?
        ;show word "actorReceiver : " actorReceiver
      ]
    ]
  ]
  if(actorReceiver = nobody and Chooser-whom-to-send = "attractiveness_manual")[
    let actorsSorted sort friendship-neighbors
    let attractivenessManualSum 0
    foreach actorsSorted[
      let friendshipToOther friendship-with ?
      let value actor-get-turtle-link-endpoint-value friendshipToOther "manual-attractiveness"
      set attractivenessManualSum attractivenessManualSum + value 
    ]
    
    let probabilityAdopted random-float attractivenessManualSum
    ;show word "attractivenessManualSum : " word attractivenessManualSum word ", probabilityAdopted = " probabilityAdopted

    set attractivenessManualSum 0
    foreach actorsSorted[
      let friendshipToOther friendship-with ?
      let value actor-get-turtle-link-endpoint-value friendshipToOther "manual-attractiveness"
      set attractivenessManualSum attractivenessManualSum + value 

      if(actorReceiver = nobody and attractivenessManualSum > probabilityAdopted)[
        set actorReceiver ?
        ;show word "actorReceiver : " actorReceiver
      ]
    ]
  ]
  if(actorReceiver = nobody and Chooser-whom-to-send = "shared_interest")[
    let actorsSorted sort friendship-neighbors
    let sharedInterestSum 0
    foreach actorsSorted[
      set sharedInterestSum sharedInterestSum + count get-shared-iamwhats self ?
    ]

    let probabilityAdopted random-float sharedInterestSum
    ;show word "sharedInterestSum : " word sharedInterestSum word ", probabilityAdopted = " probabilityAdopted

    set sharedInterestSum 0
    foreach actorsSorted[
      set sharedInterestSum sharedInterestSum + count get-shared-iamwhats self ?
      if(actorReceiver = nobody and sharedInterestSum > probabilityAdopted)[
        set actorReceiver ?
        ;show word "actorReceiver : " actorReceiver
      ]
    ]
  ]
  if(actorReceiver = nobody and Chooser-whom-to-send = "environmental")[
  ]
  report actorReceiver
end

to-report actor-receiver-decides-on-absorption-of-activity [actorSender actorReceiver activity-current]
  let shouldAccept false
  
  if([price-absorbed] of actorReceiver >= [price-absorption-limit] of actorReceiver) [report false]

  if(random-float 1 > Activity-absorption-probability) [report false]

  if(Chooser-whom-to-receive = "anyone")[ ; IMPLEMENTED!
    set shouldAccept true
  ]
  if(Chooser-whom-to-receive = "friends")[ ; IMPLEMENTED!
    ask actorReceiver[
      set shouldAccept member? actorSender friendship-neighbors
    ]
  ]
  if(Chooser-whom-to-receive = "popularity")[
  ]
  if(Chooser-whom-to-receive = "attractiveness_manual")[
  ]
  if(Chooser-whom-to-receive = "shared_interest")[
  ]
  if(Chooser-whom-to-receive = "environmental")[
  ]
  report shouldAccept
end

; it populates activity
to actor-populate-activity [activity-current]
  set activities-num-emitted activities-num-emitted + 1
  ; select one iamwhat from actor's iamwhats
  let selected-iamwhat one-of iamwhat-actor-neighbors
  let selected-activity-type one-of activity-types;
  
                                                  ; create a link between activity and iamwhat
  ask activity-current[
    set intensity ([intensity] of selected-activity-type)
    set shape ([shape] of selected-activity-type)
    create-iamwhat-activity-with selected-iamwhat [
      set shape "default"
      set color brown
      if(Links-show-extra = false)[set hidden? true]
    ]
    create-activity-type-activity-with selected-activity-type [
      set shape "default"
      set color brown
      if(Links-show-extra = false)[set hidden? true]
    ]
  ]
end

to fm-tick-update
  ask actors[
    foreach sort my-friendships[
      actor-set-turtle-link-endpoint-value ? "time-to-lost" (-1 + actor-get-turtle-link-endpoint-value ? "time-to-lost")
    ]
  ]
end