; In order to rise error (to make it possible for this file to be loaded inside of NetLogo environment) just keep this line uncommented. There are too many error to NetLogo not notice them ;) :x. Comment it while you are running code. You need it only on loading model in NetLogo

globals[
    activities-num-emitted   ; total number of activities emitted in the system from all actors cumullatively
]

to-report diffuse-activity
  let activity-current nobody
  let actor-difuser nobody

  ;; create activity breed that will represent the activity that just happened
  create-activities 1
  [
    set activities-list lput self activities-list
    set activity-current self
    
    setxy (max-pxcor - 5) 0 ; we need to update it AFTER we se if activity DID happen in the ind
    set size 5
    ;set hidden? true
    set shape "flower"
  ]
  
  ; ask actor (actor-difuser) that is not in emittion saturation to emit an activity
  ; it will decide if it will emit it in according to emission probability
  let actor-difuser-potential one-of actors with [price-emitted < price-emission-limit]

  if(actor-difuser-potential != nobody)[
    ask actor-difuser-potential [
      ifelse (random-float 1 <= Activity-emission-probability)[
        set actor-difuser self
        actor-diffuse-activity-from activity-current
      ][
      ; type "actor : " type self type "rejected to diffuse activity\n"
      ]
    ]
  ]
  
  ; if actor 'refused' to difuse activity we have to revoke activity
  ifelse (actor-difuser = nobody)[
    ask activity-current [die]
    set activities-list but-last activities-list

  ][
    ; we add 1 since we will put overflowed activities on the first position
    let activity-y (max-pycor - 5 * (1 + length activities-list))
  
    ; type "activity-y = " type activity-y type ", min-pycor = " type min-pycor type "\n"
    if(activity-y < min-pycor + 5)[
      ask activities with [ycor < (max-pycor - 5)][
        set ycor ycor + 5;
      ]
      set activity-y min-pycor + 5
    ]

    ; all overflowed activites should be hidden together with their activity-actors links
    ask activities with [ycor >= (max-pycor - 5)][
      set hidden? true;

      ; equivalent to command my-out-<breeds>
      ask my-out-activity-actors [
        set hidden? true;
      ]
      ; equivalent to command my-in-<breeds>
      ask my-in-activity-actors [
        set hidden? true;
      ]
    ]

    ask activity-current[
      set ycor activity-y
    ]
  ]
  report activity-current
end

; the chosen actor-difuser will send activity activity-current to one (soon more) other actors that didn't reach absorption limit
to actor-diffuse-activity-from [activity-current]
  ; type "actor : " type self type "is diffusing activity\n"

  actor-populate-activity activity-current
  let activity-type-current nobody
  ; no need for one-of (there has to be only one link) except for de-agentseting to breed
  ask activity-current[set activity-type-current one-of activity-type-activity-neighbors]

  ; consider emitting price
  set price-emitted price-emitted + [price-to-diffuse] of activity-type-current

  ; create a link between actor emitter and activity
  create-activity-actor-to activity-current [
    set shape "default"
    set color yellow
    set happened true
    if(Links-show-extra = false)[set hidden? true]
  ]
  
  ; find (if any) actor that emitter is emitting activity toward
  let actor-absorbers actor-sender-choses-receiver-for-emitting-activity activity-current
  if(actor-absorbers != nobody)[

    ; ask absorber if he is willing to absorb
    let actorReceiverAccepted actor-receiver-decides-on-absorption-of-activity self actor-absorbers activity-current

    ; connect activity with absorber
    ask actor-absorbers[
      create-activity-actor-from activity-current [
        set shape "default"
        
        ifelse(actorReceiverAccepted)[
          set color red
          set happened true
        ][
          set color blue
          set happened false
        ]

        if(Links-show-extra = false)[set hidden? true]
      ]
    ]
    
    if(actorReceiverAccepted)[
      ask actor-absorbers [
        ; consider absorbtion price
        set price-absorbed price-absorbed + [price-to-absorb] of activity-type-current
      ]
      affect-relatinships-by-activity activity-current
    ]
  ]
end

; in the context of actor-sender
; it returns the most appropriate actor
to-report actor-sender-choses-receiver-for-emitting-activity [activity-current]
  let actorReceiver nobody
  if(Chooser-whom-to-send = "anyone")[ ; IMPLEMENTED!
    set actorReceiver one-of other actors with [price-absorbed < price-absorption-limit];
  ]
  if(Chooser-whom-to-send = "friends")[ ; IMPLEMENTED!
    set actorReceiver one-of friendship-neighbors with [price-absorbed < price-absorption-limit];
  ]
  if(Chooser-whom-to-send = "popularity")[
    let actorsSorted sort actors
    let popularitySum 0
    foreach actorsSorted[
      set popularitySum popularitySum + [popularity] of ?
    ]

    let probabilityAdopted random-float popularitySum
    ;show word "popularitySum : " word popularitySum word ", probabilityAdopted = " probabilityAdopted

    set popularitySum 0
    foreach actorsSorted[
      set popularitySum popularitySum + [popularity] of ?
      if(actorReceiver = nobody and popularitySum > probabilityAdopted)[
        set actorReceiver ?
        ;show word "actorReceiver : " actorReceiver
      ]
    ]
  ]
  if(Chooser-whom-to-send = "attractiveness_manual")[
    let actorsSorted sort friendship-neighbors
    let attractivenessManualSum 0
    foreach actorsSorted[
      let friendshipToOther friendship-with ?
      let value actor-get-turtle-link-endpoint-value friendshipToOther "manual-attractiveness"
      set attractivenessManualSum attractivenessManualSum + value 
    ]
    
    let probabilityAdopted random-float attractivenessManualSum
    ;show word "attractivenessManualSum : " word attractivenessManualSum word ", probabilityAdopted = " probabilityAdopted

    set attractivenessManualSum 0
    foreach actorsSorted[
      let friendshipToOther friendship-with ?
      let value actor-get-turtle-link-endpoint-value friendshipToOther "manual-attractiveness"
      set attractivenessManualSum attractivenessManualSum + value 

      if(actorReceiver = nobody and attractivenessManualSum > probabilityAdopted)[
        set actorReceiver ?
        ;show word "actorReceiver : " actorReceiver
      ]
    ]
  ]
  if(Chooser-whom-to-send = "shared_interest")[
    let actorsSorted sort actors
    let sharedInterestSum 0
    foreach actorsSorted[
      set sharedInterestSum sharedInterestSum + count get-shared-iamwhats self ?
    ]

    let probabilityAdopted random-float sharedInterestSum
    ;show word "sharedInterestSum : " word sharedInterestSum word ", probabilityAdopted = " probabilityAdopted

    set sharedInterestSum 0
    foreach actorsSorted[
      set sharedInterestSum sharedInterestSum + count get-shared-iamwhats self ?
      if(actorReceiver = nobody and sharedInterestSum > probabilityAdopted)[
        set actorReceiver ?
        ;show word "actorReceiver : " actorReceiver
      ]
    ]
  ]
  if(Chooser-whom-to-send = "environmental")[
  ]
  report actorReceiver
end

to-report actor-receiver-decides-on-absorption-of-activity [actorSender actorReceiver activity-current]
  let shouldAccept false
  
  if([price-absorbed] of actorReceiver >= [price-absorption-limit] of actorReceiver) [report false]

  if(random-float 1 > Activity-absorption-probability) [report false]

  if(Chooser-whom-to-receive = "anyone")[ ; IMPLEMENTED!
    set shouldAccept true
  ]
  if(Chooser-whom-to-receive = "friends")[ ; IMPLEMENTED!
    ask actorReceiver[
      set shouldAccept member? actorSender friendship-neighbors
    ]
  ]
  if(Chooser-whom-to-receive = "popularity")[
  ]
  if(Chooser-whom-to-receive = "attractiveness_manual")[
  ]
  if(Chooser-whom-to-receive = "shared_interest")[
  ]
  if(Chooser-whom-to-receive = "environmental")[
  ]
  report shouldAccept
end

; it populates activity
to actor-populate-activity [activity-current]
  set activities-num-emitted activities-num-emitted + 1
  ; select one iamwhat from actor's iamwhats
  let selected-iamwhat one-of iamwhat-actor-neighbors
  let selected-activity-type one-of activity-types;
  
                                                  ; create a link between activity and iamwhat
  ask activity-current[
    set intensity ([intensity] of selected-activity-type)
    create-iamwhat-activity-with selected-iamwhat [
      set shape "default"
      set color brown
      if(Links-show-extra = false)[set hidden? true]
    ]
    create-activity-type-activity-with selected-activity-type [
      set shape "default"
      set color brown
      if(Links-show-extra = false)[set hidden? true]
    ]
  ]
end